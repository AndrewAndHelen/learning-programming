## Item39:考虑对于单次事件通信使用void
转载自：https://blog.csdn.net/zhangyifei216/article/details/70991600
* 引言
```
1. 对于简单的事件通信，条件变量需要⼀个多余的互斥锁，对检测和反应任务的相对进度有约束，并且需要反应任务来验证事件是否已发⽣ 
2. 基于flag的设计避免的上⼀条的问题，但是不是真正的挂起反应任务 
3. 组合条件变量和flag使⽤，上⾯的问题都解决了，但是逻辑不让⼈愉快 
4. 使⽤ std::promise和future 的⽅案，要考虑堆内存的分配和销毁开销，同时有只能使⽤⼀次通信的限制
```

有的时候对于一个任务来说，希望有一种机制可以和另外一个任务进行通信，尤其是那种异步运行的任务，并且会出现一种特定事件的任务，另外一个任务需要等到这个事件的发生才能继续运行，典型的，可以是等待一个重要的数据结构进行初始化，或者是等待一个计算阶段完成，又或者是检测一个重要的值。那么什么样的方式可以处理好这种线程间的通信呢？

​一个很明显的方法就是使用条件变量，一个任务就等待条件变量上，等待特定事件完成后被唤醒即可，部分代码如下:
```
// cv表示一个事件，m是用来保护这个条件变量
std::condition_variable cv;
std::mutex m;

// 进行事件探测和通知
.....                   // 探测事件是否发生
cv.notify_one();        // 进行事件的通知
```

尽管使用条件变量可以达到我们想要的效果，但是未免有点复杂，等待事件的时候还需要使用mutex对条件变量进行保护，对于一些比较简单的事件来说没未免显得过重了。此外使用条件变量还需要考虑下面几个问题：
1. 如果检测任务在反应任务 wait 之前就通知了条件变量，反 应任务就会丢失这次通知，永远不被唤醒。
2. 条件变量的wait会出现虚假唤醒的问题，尽管可以通过添加一个检测条件，在被虚假唤醒的时候，再次检测指定事件是否发生，但是有的时候却没有一种可行的方式用来检测。

假设我们可以处理好上述问题，但是使用条件变量仍然会带来不少的开销，比如：在特定事件完成后必须要进行通知，接受到通知后还需要再次检查事件是否完成。这显然都是一些多余的操作。对于这个问题可以使用我们在Item38中提到的std::promise和std::future来完成，这两者构成了一个简单的channel用于通信，特定事件完成后只需要往std::promise写入一个空值来表明事件完成，那么阻塞在std::future对象上的任务就会被唤醒，部分代码如下：
```
std::promise<void> p;
p.set_value();  // 事件完成，进行通知

p.get_future().wait(); // 等待事件完成
```
虽然std::promise和std::future这种方式显得更加简单，但是这不代表它是完美的方案，这种方式需要维护一个共享状态，需要在堆上分配存储，有分配和释放的开销，并且这种事件通知也是一次性的，而条件变量的方式可以多次触发事件。
